From: <Salvo pelo Windows Internet Explorer 8>
Subject: 
Date: Wed, 18 May 2011 19:13:10 -0300
MIME-Version: 1.0
Content-Type: text/html;
	charset="Windows-1252"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://www.jstatsoft.org/v41/i04/supp/1
X-MimeOLE: Produced By Microsoft MimeOLE V6.00.2900.5994

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD>
<META content=3D"text/html; charset=3Dwindows-1252" =
http-equiv=3DContent-Type>
<META name=3DGENERATOR content=3D"MSHTML 8.00.6001.19019"></HEAD>
<BODY><PRE>####################################
## 2.1 The local level model in R ##
####################################

fitNile &lt;- StructTS(Nile, "level")
fitNile

plot(Nile, type =3D "o")
lines(fitted(fitNile), lty =3D "dashed", lwd =3D 2)
lines(tsSmooth(fitNile), lty =3D "dotted", lwd =3D 2)

library("forecast")
plot(forecast(fitNile, level =3D c(50, 90), h =3D 10), xlim =3D c(1950, =
1980))


#################################################
## 2.2. The local level model with package dlm ##
#################################################

library("dlm")
mod &lt;- dlmModPoly(1, dV =3D 0.3, dW =3D 0.01)

buildNile &lt;- function(theta) {
  dlmModPoly(order =3D 1, dV =3D theta[1], dW =3D theta[2])
}

fit &lt;- dlmMLE(Nile, parm =3D c(100, 2), buildNile, lower =3D =
rep(1e-4, 2))

modNile &lt;- buildNile(fit$par)
drop(V(modNile)) # sigma2_epsilon
drop(W(modNile)) # sigma2_xi

library("numDeriv")
hs &lt;- hessian(function(x) dlmLL(Nile, buildNile(x)), fit$par)
all(eigen(hs, only.values =3D TRUE)$values &gt; 0)

aVar &lt;- solve(hs)
sqrt(diag(aVar))

smoothNile &lt;- dlmSmooth(Nile, modNile)

hwidth &lt;- qnorm(0.05, lower =3D FALSE) *
  sqrt(unlist(dlmSvd2var(smoothNile$U.S, smoothNile$D.S)))
sm &lt;- cbind(smoothNile$s, as.vector(smoothNile$s) + hwidth %o% c(-1, =
1))

filterNile &lt;- dlmFilter(Nile, modNile)
plot(residuals(filterNile, sd =3D FALSE), type =3D "o",
  ylab =3D "Standardized prediction error")
abline(h =3D 0)

foreNile &lt;- dlmForecast(filterNile, nAhead =3D 10)
attach(foreNile)
hwidth &lt;- qnorm(0.25, lower =3D FALSE) * sqrt(unlist(Q))
fore &lt;- cbind(f, as.vector(f) + hwidth %o% c(-1, 1))
rg &lt;- range(c(fore, window(Nile, start =3D c(1951, 1))))
plot(fore, type =3D "o", pch =3D 16, plot.type =3D "s", lty =3D c(1, 3, =
3),
  ylab =3D "Nile level", xlab =3D "", xlim =3D c(1951, 1980), ylim =3D =
rg)
lines(window(Nile, start =3D c(1951, 1)), type =3D 'o')
lines(window(smoothNile$s, start =3D c(1951,1)), lty =3D 5)
abline(v =3D mean(c(time(f)[1], tail(time(Nile), 1))),
  lty =3D "dashed", col =3D "darkgrey")
legend("topleft", lty =3D c(1, 5, 1, 3), pch =3D c(1, NA, 16, 16), bty =
=3D "n",
  legend =3D c("observed level", "smoothed level", "forecasted level",
    "50% probability limits"))
detach(foreNile)


#############################################
## The local level model with package KFAS ##
#############################################

library("KFAS")
logLik &lt;- function(theta) {
  lik &lt;- kf(yt =3D Nile, Zt =3D 1, Tt =3D 1, Rt =3D 1, Ht =3D =
theta[1],
    Qt =3D theta[2], a1 =3D 0, P1 =3D 1e7)
  return(-lik$lik)
}
fit &lt;- optim(par =3D c(100, 2), fn =3D logLik, lower =3D rep(1e-4, =
2))

filterNile &lt;- kf(yt =3D Nile, Zt =3D 1, Tt =3D 1, Rt =3D 1, Ht =3D =
fit$par[1],
  Qt =3D fit$par[2], a1 =3D 0, P1 =3D 1e7)
smoothNile &lt;- ks(filterNile)
attach(smoothNile)
hwidth &lt;- qnorm(0.05, lower =3D FALSE) * sqrt(drop(Vt))
sm &lt;- cbind(drop(ahat), as.vector(ahat) + hwidth %o% c(-1, 1))
sm &lt;- ts(sm, start =3D start(Nile))
plot(sm, plot.type =3D "s", type =3D "l", lty =3D c(1, 5, 5),
  ylab =3D "Level", xlab =3D "", ylim =3D range(Nile))
lines(Nile, type =3D "o", col =3D "darkgrey")
legend("bottomleft", col =3D c("darkgrey", rep("black", 2)),
  lty =3D c(1, 1, 5), pch =3D c(1, NA, NA), bty =3D "n", legend =3D
  c("data", "smoothed level", "90% probability limits"))
detach(smoothNile)

residNile &lt;- drop(filterNile$vtuni / sqrt(filterNile$Ftuni))

foreNile &lt;- forecast(filterNile, fc =3D 9)
attach(foreNile)
hwidth &lt;- qnorm(0.25, lower =3D FALSE) * sqrt(drop(Pt.fc))
fore &lt;- ts(cbind(drop(at.fc), drop(at.fc) + hwidth %o% c(-1, 1)),
  start =3D 1 + end(Nile)[1])
rg &lt;- range(c(fore, window(Nile, start =3D c(1951, 1))))
detach(foreNile)


#######################################################
## 2.4. Bayesian inference for the local level model ##
#######################################################

set.seed(123)
gibbsOut &lt;- dlmGibbsDIG(Nile, mod =3D dlmModPoly(1), shape.y =3D 0.1,
  rate.y =3D 0.1, shape.theta =3D 0.1, rate.theta =3D 0.1, n.sample =3D =
10000,
  thin =3D 9)

burn &lt;- 1:1000
attach(gibbsOut)
ts.plot(ergMean(dV[-burn]), ylab =3D "sample mean", xlab =3D =
"iterations",
  main =3D "obs variance")
ts.plot(ergMean(dW[-burn]), ylab =3D "sample mean", xlab =3D =
"iterations",
  main =3D "evolution variance")
acf(dV[-burn])
acf(dW[-burn])

plot(density(dV[-burn]), xlim =3D c(2000, 34000), ylab =3D "", main =3D =
"")
hist(dV[-burn], prob =3D TRUE, add =3D TRUE)
curve(dgamma(1/x, shape =3D 0.1, rate =3D 0.1) / x^2, lty =3D "dashed",
  add =3D TRUE)
plot(density(dW[-burn]), ylab =3D "", xlim =3D c(0, 16000),  main =3D =
"")
hist(dW[-burn], prob =3D TRUE, add =3D TRUE)
curve(dgamma(1/x, shape =3D 0.1, rate =3D 0.1) / x^2, lty =3D "dashed",
  add =3D TRUE)
plot(dV[-burn], dW[-burn], pch =3D ".", cex =3D 1.5, ylab =3D "")

mcmcMean(dV[-burn])
mcmcMean(dW[-burn])
quantile(dV[-burn], c(0.025, 0.975))
quantile(dW[-burn], c(0.025, 0.975))

lastTheta &lt;- theta[length(Nile) + 1, , ]
levelSim &lt;- matrix(0, nr =3D 10, nc =3D 10000)
for (it in 1:10000) {
  innovSim &lt;- rnorm(10, sd =3D sqrt(dW[it]))
  levelSim[, it] &lt;- cumsum(innovSim) + lastTheta[it]
}
ySim &lt;- matrix(0, nr =3D 10, nc =3D 10000)
for (it in 1:10000) {
  innov &lt;- rnorm(10, sd =3D sqrt(dV[it]))
  ySim[, it] &lt;- innov + levelSim[, it]
}
yInts &lt;- apply(ySim, 1, function(x) quantile(x, c(0.25, 0.75)))


#################################
## 3.1. Intervention variables ##
#################################

x &lt;- matrix(c(rep(0, 27), rep(1, length(Nile) - 27)), ncol =3D 1)
modNileReg &lt;- dlmModReg(x, dW =3D c(1, 0))
buildFun &lt;- function(theta) {
  V(modNileReg) &lt;- exp(theta[1])
  diag(W(modNileReg))[1] &lt;- exp(theta[2])
  return(modNileReg)
}
fit &lt;- dlmMLE(Nile, parm =3D rep(0, 2), build =3D buildFun)
modNileReg &lt;- buildFun(fit$par)
drop(V(modNileReg))
W(modNileReg)[1]

modSmooth &lt;- dlmSmooth(Nile, mod =3D modNileReg)
plot(Nile, type =3D "o")
lines(ts(modSmooth$s[-1, 1] + modSmooth$s[-1, 2] * x, start =3D 1871), =
lty =3D 2)


#######################################################
## 3.2. Structural time series and model composition ##
#######################################################

lGas &lt;- log(UKgas)
dlmGas &lt;- dlmModPoly() + dlmModSeas(4)
buildFun &lt;- function(x) {
  diag(W(dlmGas))[2:3] &lt;- exp(x[1:2])
  V(dlmGas) &lt;- exp(x[3])
  return(dlmGas)
}
fit &lt;- dlmMLE(lGas, parm =3D rep(0, 3), build =3D buildFun)
dlmGas &lt;- buildFun(fit$par)
drop(V(dlmGas))
diag(W(dlmGas))[2:3]

gasSmooth &lt;- dlmSmooth(lGas, mod =3D dlmGas)
x &lt;- cbind(lGas, dropFirst(gasSmooth$s[, c(1, 3)]))
colnames(x) &lt;- c("Gas", "Trend", "Seasonal")
plot(x, type =3D "o", main =3D "UK Gas Consumption")


##############################
## 3.3. Multivariate models ##
##############################

modUni &lt;- dlmModPoly(1)
modUni %+% modUni %+% modUni
do.call(dlmSum, rep(list(modUni), 13))

tmp &lt;- ts(read.table("P.txt", header =3D TRUE), start =3D c(1978, 1), =
frequency =3D 12) * 100
y &lt;- tmp[, 1:4] - tmp[, "RKFREE"]
colnames(y) &lt;- colnames(tmp)[1:4]
market &lt;- tmp[, "MARKET"] - tmp[, "RKFREE"]
rm("tmp")
m &lt;- NCOL(y)

Zt &lt;- sapply(seq_along(market), function(i) market[i] %x% diag(m))
dim(Zt) &lt;- c(m, m, length(market))
Rt &lt;- diag(nr =3D m)
logLik &lt;- function(theta) {
  a &lt;- diag(exp(0.5 * theta[1:m]), nr =3D m)
  a[upper.tri(a)] &lt;- theta[(m + 1):k]
  Ht &lt;- crossprod(a)
  a &lt;- diag(exp(0.5 * theta[1:m + k]), nr =3D m)
  a[upper.tri(a)] &lt;- theta[-(1:(k + m))]
  Qt &lt;- crossprod(a)
  lik &lt;- kf(yt =3D t(y), Zt =3D Zt, Tt =3D diag(nr =3D m), Rt =3D Rt, =
Ht =3D Ht,
    Qt =3D Qt, a1 =3D rep(0, m), P1 =3D matrix(0, m, m),
    P1inf =3D diag(rep(1, m)), optcal =3D c(FALSE, FALSE, FALSE, FALSE))
  return(-lik$lik)
}
fit &lt;- optim(par =3D rep(0, 2 * k), fn =3D logLik, method =3D "BFGS",
  control =3D list(maxit =3D 500))
fit$conv

theta &lt;- fit$par
a &lt;- diag(exp(0.5 * theta[1:m]), nr=3Dm)
a[upper.tri(a)] &lt;- theta[(m+1):k]
Ht &lt;- crossprod(a)
a &lt;- diag(exp(0.5 * theta[1:m + k]), nr=3Dm)
a[upper.tri(a)] &lt;- theta[-(1:(k + m))]
Qt &lt;- crossprod(a)
smoothCAPM &lt;- ks(kf(yt =3D t(y), Zt =3D Zt, Tt =3D diag(nr =3D m), Rt =
=3D Rt,
  Ht =3D Ht, Qt =3D Qt, a1 =3D rep(0, m), P1 =3D matrix(0, m, m),
  P1inf =3D diag(rep(1, m))))
betas &lt;- ts(t(smoothCAPM$ahat), start =3D start(market),
  freq =3D frequency(market))
</PRE></BODY></HTML>
